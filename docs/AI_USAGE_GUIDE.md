# BuildX.work AI 使用教程

> 本教程帮助开发者快速上手使用 Cursor AI 助手进行开发，包括如何使用指令、创建规则、保存经验和记录技术栈。

## 📚 目录

- [快速开始](#快速开始)
- [可用指令列表](#可用指令列表)
- [如何执行指令](#如何执行指令)
- [常见使用场景](#常见使用场景)
- [创建和管理指令](#创建和管理指令)
- [创建和管理规则](#创建和管理规则)
- [保存开发经验](#保存开发经验)
- [记录技术栈规则](#记录技术栈规则)
- [最佳实践](#最佳实践)
- [常见问题](#常见问题)

## 快速开始

### 什么是 Cursor AI？

Cursor 是一个 AI 驱动的代码编辑器，它可以帮助你：

- 🤖 **智能代码生成**：根据上下文自动生成代码
- 🔍 **代码搜索和理解**：快速理解代码库结构
- 🛠️ **自动化任务**：执行重复性开发任务
- 📝 **文档生成**：自动生成文档和注释

### 项目中的 AI 功能

BuildX.work 项目集成了以下 AI 功能：

1. **指令系统**：定义 AI 的工作方式和行为模式
2. **规则系统**：提供开发规范和最佳实践
3. **经验库**：记录开发中遇到的问题和解决方案
4. **技术栈文档**：记录技术栈的使用规范和参考

### 5 分钟快速上手

#### 第一步：了解可用指令

在 Cursor 中，你可以使用斜线命令（`/`）来执行指令。例如：

- `/continue-project-work` - 继续完成项目工作
- `/smart-go` - 智能继续工作
- `/daily-report` - 生成日报

#### 第二步：执行第一个指令

尝试执行一个简单的指令：

```
/continue-project-work
```

AI 会自动：
1. 查看项目状态
2. 识别下一步任务
3. 执行任务
4. 更新进度

#### 第三步：查看指令详情

所有指令文件都在 `.cursor/commands/` 目录下，你可以查看指令文件了解每个指令的详细用法。

#### 第四步：开始使用

现在你可以：
- 使用指令继续项目工作
- 使用指令生成日报
- 使用指令优化界面
- 查看下面的[可用指令列表](#可用指令列表)了解更多指令

## 可用指令列表

### 项目工作指令

#### 🚀 继续完成项目工作 (`/continue-project-work`)

**用途**：继续完成指定项目的下一步工作。根据项目文档、进度文件、TODO 列表等，识别下一步应该完成的任务并执行。

**使用方式**：
- **Cursor 斜线命令**：`/continue-project-work [项目：项目名]`
- **直接描述**：`继续完成项目工作，项目：[项目名]`
- **不指定项目**：`/continue-project-work` 或 `继续完成项目工作`（AI 会列出所有项目让你选择）

**工作流程**：
1. 识别项目（如果未指定，列出所有项目）
2. 查看项目状态（CURRENT_WORK.md、进度文件、TODO 列表）
3. 识别下一步任务（按优先级排序）
4. 执行任务（实现功能、编写测试、修复问题等）
5. 更新进度（更新进度文件和文档）
6. 报告结果（已完成的任务和下一步建议）

**适用场景**：
- 需要继续项目开发
- 需要执行具体任务
- 需要更新项目进度

**指令文件**：`.cursor/commands/00-continue.md`

---

#### 🎯 智能继续工作 (`/smart-go`)

**用途**：智能继续执行当前任务，自主决定下一步工作，不要停下来汇报进度。适用于需要持续工作、自主决策的场景。

**使用方式**：
- **Cursor 斜线命令**：`/smart-go`
- **直接描述**：`智能继续工作`、`继续执行当前任务`

**工作流程**：
1. 继续当前任务（如提升代码覆盖率）
2. 检查项目状态（TODO 列表、项目文档、当前进度）
3. 决定下一步（根据最佳实践和项目状态，自主决定下一个任务）
4. 持续执行（完成任务后立即开始下一个，不中断、不汇报）
5. 只在必要时停止（所有任务完成时报告，或遇到需要用户决策的问题时询问）

**与 `continue-project-work` 的区别**：
- **continue-project-work**：会执行操作并报告结果
- **smart-go**：直接继续工作，不需要制定计划或等待确认，自主决定下一步

**适用场景**：
- 需要持续工作
- 需要自主决策
- 不需要频繁汇报

**指令文件**：`.cursor/commands/01-smart-go.md`

---

#### 🤖 自主工作 (`/autonomous-work`)

**用途**：AI 完全自主工作，持续完成任务直到完成。适用于需要完全托管给 AI 的场景。

**使用方式**：
- **Cursor 斜线命令**：`/autonomous-work`
- **直接描述**：`自主工作`、`完全托管给你`、`我去休息了，接下来的工作就完全托管给你`

**重要规则**：
- ⚠️ **必须先制定计划并等待确认**：收到指令后，必须先制定计划并展示给用户，等待用户确认后才能开始执行
- ⚠️ **禁止直接开始执行**：在用户确认之前，禁止执行任何任务

**工作流程**：
1. 查看当前计划（项目文档、进度文件、计划文档）
2. **制定执行计划**（必须执行，不能跳过）：
   - 列出所有待完成任务
   - 按优先级排序
   - 制定详细的执行步骤
   - **向用户展示计划**
   - **等待用户确认**
3. **等待用户确认**（关键步骤，不能跳过）：
   - 必须等待用户明确确认
   - 禁止直接开始执行
4. **自主执行**（确认后）：
   - 按优先级顺序执行
   - 每个任务完整完成（实现功能、编写测试、运行测试、检查 linter、更新文档）
   - 持续工作，不要停下来
   - 遇到问题必须持续尝试解决
5. **工作完成**：
   - 所有计划任务完成
   - 所有测试通过（0 失败、0 错误）
   - 没有 linter 错误
   - 文档已更新
   - 向用户报告完成情况

**适用场景**：
- 需要完全托管给 AI
- 需要批量完成任务
- 需要持续工作直到完成

**指令文件**：`.cursor/commands/02-autonomous-work.md`

---

#### 📝 日报管理 (`/daily-report`)

**用途**：在工作结束时记录项目开发进度、回顾今天的工作内容，生成员工日报并附加到日报文件中。

**使用方式**：
- **Cursor 斜线命令**：`/daily-report`
- **直接描述**：`记录进度，更新统计，结束今天的工作`、`生成日报`、`结束今天的工作`

**重要功能**：
- **检查缺失的日报**：首次对话时，会自动检查从上次日报日期到昨天之间的所有日期是否都有日报，如有缺失会提醒补写
- **自动追踪工作**：主要通过 Git 提交历史追踪工作，这是最准确的方法
- **生成日报**：自动生成日报并附加到日报文件中（按年月归档）

**工作流程**：
1. **检查缺失的日报**（首次对话时）：
   - 检查从上次日报日期到昨天之间的所有日期是否都有日报
   - 如有缺失，提醒并询问是否补写
   - 如确认补写，按日期顺序依次补写所有缺失的日报
2. **获取操作者信息**：
   - 使用 `git config` 获取用户名和邮箱
   - 验证 Git 提交历史中的身份
3. **回顾今天的工作内容**：
   - 分析 Git 提交历史（主要方法）
   - 分析文件修改记录（补充方法）
   - 结合项目进度文件（补充信息）
   - 检查测试覆盖率
   - 汇总今天的工作
4. **生成员工日报**：
   - 确定日报文件路径（`daily-reports/[员工姓名]-[年份]-[月份].md`）
   - 生成日报内容（日期、工作回顾、Git 提交详情、统计数据、工作总结、明日计划）
   - 附加到日报文件
5. **验证数据一致性**：
   - 确保所有数据准确

**适用场景**：
- 每天工作结束时
- 需要记录工作进度
- 需要生成日报

**指令文件**：`.cursor/commands/03-daily-report.md`

---

#### 🔍 询问下一步 (`/what-next`)

**用途**：询问项目下一步该做什么，只回答建议，不执行任何操作。适用于需要了解项目状态、获取下一步建议的场景。

**使用方式**：
- **Cursor 斜线命令**：`/what-next`
- **直接描述**：`下一步该做什么`、`我应该做什么`、`接下来做什么`

**工作流程**：
1. 查看当前工作状态（CURRENT_WORK.md、进度文件、TODO 列表）
2. 分析项目状态（项目文档、功能清单、开发计划）
3. 提供建议（按优先级排序，说明原因和重要性）
4. **不执行任何操作**（只回答建议，不修改文件，不运行命令）

**与其他指令的区别**：
- **continue-project-work**：会执行操作
- **smart-go**：会执行操作
- **autonomous-work**：会执行操作
- **what-next**：只回答建议，不执行任何操作

**适用场景**：
- 需要了解项目状态
- 需要获取下一步建议
- 需要决策下一步做什么

**指令文件**：`.cursor/commands/04-what-next.md`

---

### 项目创建指令

#### 💼 商业价值分析 (`/business-analysis`)

**用途**：评估项目的商业价值，从投资人、用户、产品经理等多个角度进行分析。适用于创建新项目、项目规划、可行性分析等场景。

**使用方式**：
- **Cursor 斜线命令**：`/business-analysis`
- **触发场景**：用户提到"创建新项目"、"新项目规划"、"项目可行性分析"、"商业价值分析"等关键词时，AI 应该自动执行

**核心原则**：
- **主动分析，不要等待反馈**：AI 应该主动进行全面的商业价值分析，而不是等待用户提供信息或反馈
- **多角色视角**：同时站在投资人、用户、产品经理的角度进行分析
- **数据驱动**：基于市场数据、用户需求、竞争分析做出判断
- **决策导向**：不仅要分析，还要给出明确的建议和决策

**工作流程**：
1. **市场机会分析**：市场规模评估、市场趋势分析、竞争格局分析
2. **用户需求分析**：目标用户画像、痛点分析、需求验证、付费意愿评估
3. **商业模式设计**：价值主张设计、盈利模式设计、成本结构分析、单位经济分析
4. **竞争优势分析**：技术壁垒、数据壁垒、网络效应、品牌优势
5. **功能优先级评估**：功能价值评估、优先级排序、MVP 功能清单
6. **风险评估**：市场风险、技术风险、商业风险、执行风险
7. **创建商业价值分析文档**：创建 `BUSINESS_ANALYSIS.md` 文档，包含所有分析结果

**适用场景**：
- 创建新项目
- 项目规划
- 可行性分析
- 商业价值评估

**指令文件**：`.cursor/commands/70-business-analysis.md`

---

### 代码管理指令

#### 🔄 代码贡献 (`/contribute-code`)

**用途**：自动识别当前项目中可以贡献给 BuildX.work 基础平台的代码，并协助智能合并到贡献分支，准备通过 GitHub Pull Request 提交。适用于 fork 项目（业务项目）。

**使用方式**：
- **Cursor 斜线命令**：`/contribute-code`
- **直接描述**：`找出可以贡献的代码`、`检查是否有可以贡献的代码`、`贡献代码到基础平台`

**核心原则**：
- **自动化流程**：AI 应该自动执行所有步骤，减少用户手动操作
- **自动处理分支状态**：如果分支不干净，自动暂存到独立分支，不询问用户
- **严格检查**：必须满足所有前置条件才能继续（upstream remote 必须正确）
- **智能识别**：智能识别可贡献代码，区分基础功能和业务功能
- **智能合并**：智能合并代码到贡献分支，处理位置差异
- **用户确认**：关键步骤需要用户确认，确保贡献的代码正确

**工作流程**：
1. **检查 Upstream Remote**（必须）：确保 upstream remote 存在且指向正确的 buildx.work GitHub 仓库
2. **拉取 Upstream 最新代码**：确保本地有最新的基础平台代码用于对比
3. **检查当前分支状态并自动处理**：如果分支不干净，自动暂存到独立分支
4. **对比代码差异并识别可贡献代码**：对比当前分支和 upstream/main 的代码差异，识别可以贡献的代码
5. **生成贡献建议并等待用户确认**：生成详细的贡献建议报告，等待用户确认
6. **创建贡献分支并智能合并代码**：如果用户确认，创建基于 upstream/main 的贡献分支，并智能合并可贡献的代码
7. **生成 PR 提交指南**：生成详细的 GitHub Pull Request 提交指南
8. **清理贡献分支，回到之前的工作**：贡献完成后，清理贡献分支，切换回之前的工作分支

**适用场景**：
- Fork 项目（业务项目）
- 识别可以贡献给基础平台的代码
- 准备通过 GitHub Pull Request 提交贡献

**指令文件**：`.cursor/commands/80-contribute-code.md`

---

#### 🔀 同步基础平台更新 (`/sync-upstream`)

**用途**：将基础平台（buildx.work）的更新同步到业务项目（fork 项目），使用 rebase 方式保持提交历史的线性。

**使用方式**：
- **Cursor 斜线命令**：`/sync-upstream`
- **直接描述**：`同步基础平台更新`、`rebase upstream main`、`合并基础平台代码`、`同步上游代码`

**核心原则**：
- **自动保存工作**：如果分支不干净，自动创建分支保存当前工作，不询问用户
- **风险分析优先**：先分析更新内容和潜在影响，给出详细风险提示
- **用户确认**：必须等待用户明确确认后才执行 rebase
- **信息透明**：显示将要同步的更新内容、风险分析和影响评估
- **自动处理**：使用 `GIT_EDITOR=true` 避免 vim 弹窗，自动完成 rebase
- **冲突处理**：检测并协助处理 rebase 过程中的冲突
- **可回退**：提供回退选项，确保操作安全

**工作流程**：
1. **检查项目类型和 Git 状态**：确认当前项目是 fork 项目，检查 Git 状态并自动处理
2. **检查 upstream remote 配置**：确保 upstream remote 已配置
3. **获取 upstream 最新代码**：获取基础平台 main 分支的最新代码
4. **深度分析更新内容和风险评估**：深度分析基础平台的更新内容，识别可能影响业务项目的文件，评估冲突风险
5. **显示风险报告并等待确认**：生成详细的风险报告，等待用户确认后再执行 rebase
6. **执行 rebase**：用户确认后执行 rebase 操作
7. **处理冲突**（如有）：如果 rebase 过程中出现冲突，协助用户处理
8. **清理并切换回之前的工作**：rebase 完成后，清理并切换回之前的工作分支
9. **验证和总结**：验证 rebase 结果，显示同步总结

**适用场景**：
- Fork 项目（业务项目）
- 需要同步基础平台的更新
- 需要保持提交历史的线性

**指令文件**：`.cursor/commands/81-sync-upstream.md`

---

#### 📝 Git 提交助手 (`/commit-assistant`)

**用途**：识别当前 git 工作区的变更内容，分析是否需要拆分成多条 commit，并协助用户进行代码签入。

**使用方式**：
- **Cursor 斜线命令**：`/commit-assistant`
- **直接描述**：`协助提交代码`、`检查 git changes`、`分析提交内容`、`拆分 commit`

**重要规则**：
- **每次 commit 之前都需要人工确认**：必须等待用户明确确认后才能执行提交

**核心原则**：
- **全面分析**：全面分析所有 git changes，包括 staged 和 unstaged 的文件
- **智能分组**：根据变更类型、功能模块、文件类型等智能分组
- **建议拆分**：识别需要拆分的变更，提供拆分建议
- **人工确认**：每次 commit 之前必须等待用户确认
- **规范提交**：使用规范的提交信息格式（Conventional Commits）

**工作流程**：
1. **检查 Git 状态**：获取当前 git 工作区的完整状态
2. **分析变更内容**：详细分析每个变更文件的内容，理解变更的目的和类型
3. **判断是否需要拆分**：根据变更内容，判断是否需要拆分成多条 commit
4. **生成提交建议**：为每条 commit 生成规范的提交信息建议
5. **等待用户确认并执行**：等待用户确认每条 commit，然后执行提交

**适用场景**：
- 需要提交代码
- 需要规范提交信息
- 需要拆分 commit

**指令文件**：`.cursor/commands/90-commit-assistant.md`

---

### 设计优化指令

#### 🎨 UI 设计专家 (`/ui-design-expert`)

**用途**：以专业 UI/UX 设计师的角度，优化和设计用户界面。适用于界面优化、响应式设计、用户体验改进、视觉设计等场景。

**使用方式**：
- **Cursor 斜线命令**：`/ui-design-expert`
- **触发场景**：用户提到"优化界面"、"改进 UI"、"设计界面"、"移动端优化"、"响应式设计"、"用户体验"、"UI 设计"等关键词时，AI 应该自动执行

**核心原则**：
- **用户为中心**：所有设计决策都要以用户体验为核心
- **一致性**：保持设计风格、组件、交互的一致性
- **响应式优先**：移动端优先，确保在所有设备上都有良好体验
- **可访问性**：确保界面对所有用户都友好（包括残障用户）
- **性能考虑**：设计时考虑加载速度和性能影响
- **现代设计规范**：遵循现代 UI/UX 设计最佳实践

**工作流程**：
1. **界面分析**：当前状态评估、用户体验分析、技术栈分析
2. **设计优化方案**：布局优化、组件优化、响应式优化、视觉优化
3. **实施优化**：代码修改、样式优化、组件优化、测试验证
4. **设计规范文档**：记录设计决策、更新设计规范

**适用场景**：
- 优化界面
- 改进 UI
- 设计界面
- 移动端优化
- 响应式设计

**指令文件**：`.cursor/commands/82-ui-design-expert.md`

---

### 其他指令

除了上述主要指令外，还有以下指令：

- **项目规划指令**（70-79 系列）：商业价值分析、项目规划、产品设计、项目命名、技术选型、数据模型、特殊功能、开发计划、文档索引、项目初始化
- **其他工具指令**：changelog、review-and-summarize 等

**查看所有指令**：`.cursor/commands/` 目录下查看所有指令文件

---

## 如何执行指令

### 方式 1：使用斜线命令（推荐）

在 Cursor 中输入斜线命令（`/`），然后输入指令名称（不含 `.md` 扩展名）：

```
/continue-project-work
/smart-go
/daily-report
```

### 方式 2：直接描述

直接描述你想要执行的操作，AI 会自动识别：

```
继续完成项目工作
智能继续工作
生成日报
优化界面
```

### 方式 3：指定参数

某些指令支持参数，可以在斜线命令中指定：

```
/continue-project-work 项目：项目名
```

或者在描述中指定：

```
继续完成项目工作，项目：项目名
```

---

## 常见使用场景

### 场景 1：开始新的一天工作

**目标**：了解项目状态，继续完成项目工作

**步骤**：
1. 使用 `/what-next` 查看下一步该做什么
2. 使用 `/continue-project-work` 继续完成项目工作

**示例**：
```
/what-next
→ AI 提供下一步建议

/continue-project-work
→ AI 执行任务并更新进度
```

---

### 场景 2：结束一天的工作

**目标**：记录工作进度，生成日报

**步骤**：
1. 使用 `/daily-report` 生成日报

**示例**：
```
/daily-report
→ AI 自动：
  1. 检查缺失的日报（首次对话时）
  2. 获取操作者信息
  3. 回顾今天的工作内容（通过 Git 提交历史）
  4. 生成员工日报
  5. 附加到日报文件
```

---

### 场景 3：优化用户界面

**目标**：优化界面，改进用户体验

**步骤**：
1. 使用 `/ui-design-expert` 或直接描述"优化界面"

**示例**：
```
优化这个页面的移动端显示
→ AI 自动：
  1. 分析当前界面
  2. 提供优化方案
  3. 实施优化
  4. 说明改进
```

---

### 场景 4：创建新项目

**目标**：创建新项目，进行商业价值分析

**步骤**：
1. 使用 `/business-analysis` 或直接描述"创建新项目"

**示例**：
```
我想做一个 [项目类型] 平台
→ AI 自动：
  1. 市场机会分析
  2. 用户需求分析
  3. 商业模式设计
  4. 竞争优势分析
  5. 功能优先级评估
  6. 风险评估
  7. 创建商业价值分析文档
```

---

### 场景 5：贡献代码到基础平台

**目标**：识别可以贡献的代码，准备提交 PR

**步骤**：
1. 使用 `/contribute-code` 识别可贡献代码
2. 确认贡献建议
3. 创建贡献分支
4. 提交 PR

**示例**：
```
/contribute-code
→ AI 自动：
  1. 检查 upstream remote
  2. 拉取 upstream 最新代码
  3. 检查分支状态并自动处理
  4. 对比代码差异并识别可贡献代码
  5. 生成贡献建议并等待确认
  6. 创建贡献分支并智能合并代码
  7. 生成 PR 提交指南
  8. 清理贡献分支，回到之前的工作
```

---

### 场景 6：同步基础平台更新

**目标**：同步基础平台的更新到业务项目

**步骤**：
1. 使用 `/sync-upstream` 同步更新

**示例**：
```
/sync-upstream
→ AI 自动：
  1. 检查项目类型和 Git 状态
  2. 检查 upstream remote 配置
  3. 获取 upstream 最新代码
  4. 深度分析更新内容和风险评估
  5. 显示风险报告并等待确认
  6. 执行 rebase（用户确认后）
  7. 处理冲突（如有）
  8. 清理并切换回之前的工作
  9. 验证和总结
```

---

### 场景 7：提交代码

**目标**：规范提交代码，拆分 commit

**步骤**：
1. 使用 `/commit-assistant` 分析变更并提交

**示例**：
```
/commit-assistant
→ AI 自动：
  1. 检查 Git 状态
  2. 分析变更内容
  3. 判断是否需要拆分
  4. 生成提交建议
  5. 等待用户确认并执行
```

---

### 场景 8：完全托管给 AI

**目标**：让 AI 完全自主工作，持续完成任务

**步骤**：
1. 使用 `/autonomous-work` 或直接描述"完全托管给你"

**示例**：
```
我去休息了，接下来的工作就完全托管给你
→ AI 自动：
  1. 查看当前计划
  2. 制定执行计划（必须）
  3. 向用户展示计划（必须）
  4. 等待用户确认（必须）
  5. 自主执行（确认后）
  6. 工作完成并报告
```

---

## 创建和管理指令

### 什么是指令？

指令（Commands）是 `.md` 文件，用于定义 AI 助手在特定场景下的工作方式和行为模式。与规则不同，指令不是提供开发规范，而是定义 AI 的工作流程。

### 指令文件位置

所有指令文件存放在 `.cursor/commands/` 目录下，文件扩展名为 `.md`。

### 创建新指令

#### 1. 确定指令主题

在创建指令前，先思考：

- 需要定义什么工作方式？
- 需要规范什么行为模式？
- 这个指令适用于什么场景？

#### 2. 创建指令文件

在 `.cursor/commands/` 目录下创建新的 `.md` 文件：

```bash
# 使用命令行创建
touch .cursor/commands/my-command.md

# 或使用 Cursor 编辑器直接创建
```

**命名规范**：

- ✅ 使用小写字母和连字符：`my-command.md`
- ✅ 使用描述性名称：`autonomous-work.md`、`code-review.md`
- ✅ 可以使用数字前缀：`00-continue.md`、`01-smart-go.md`（方便快速执行）
- ❌ 避免使用下划线：`my_command.md`
- ❌ 避免使用空格：`my command.md`

#### 3. 编写指令内容

指令文件使用 Markdown 格式，**不需要**头部元数据字段（与规则文件不同）。

**推荐结构**：

```markdown
# 指令文件标题

## 触发场景

说明何时应该使用这个指令...

## 核心原则

1. 原则 1
2. 原则 2

## 工作流程

### 1. 步骤 1

详细说明...

### 2. 步骤 2

详细说明...

## 重要规则

- 规则 1
- 规则 2

## 注意事项

1. 注意事项 1
2. 注意事项 2
```

#### 4. 使用指令

在 Cursor 中使用斜线命令执行指令：

```bash
# 使用斜线命令
/continue-project-work

# 或直接描述
继续完成项目工作，项目：项目名
```

### 更新现有指令

直接编辑 `.cursor/commands/` 目录下的 `.md` 文件即可。修改后，AI 会自动识别新的指令内容。

### 指令文件示例

查看现有指令文件作为参考：

- **00-continue.md**：继续完成项目工作指令
- **01-smart-go.md**：智能继续工作指令
- **02-autonomous-work.md**：自主工作模式指令
- **03-daily-report.md**：日报管理指令

### 参考文档

详细指南请参考：`.cursor/rules/cursor-commands.mdc`

## 创建和管理规则

### 什么是规则？

规则（Rules）是 `.mdc` 文件，用于为 AI 助手提供开发规范和指导。当开发相关功能时，AI 会自动参考这些规则文件，确保遵循最佳实践。

### 规则文件位置

所有规则文件存放在 `.cursor/rules/` 目录下，文件扩展名为 `.mdc`。

### 创建新规则

#### 1. 确定规则主题

在创建规则前，先思考：

- 是否已有相关规则文件？
- 是否需要创建新的规则文件？
- 规则文件应该包含哪些内容？

#### 2. 创建规则文件

在 `.cursor/rules/` 目录下创建新的 `.mdc` 文件：

```bash
# 使用命令行创建
touch .cursor/rules/my-rule.mdc

# 或使用 Cursor 编辑器直接创建
```

**命名规范**：

- ✅ 使用小写字母和连字符：`my-rule.mdc`
- ✅ 使用描述性名称：`authentication.mdc`、`daisy-ui.mdc`
- ❌ 避免使用下划线：`my_rule.mdc`
- ❌ 避免使用空格：`my rule.mdc`

#### 3. 编写头部元数据

规则文件**必须**包含头部元数据字段：

```markdown
---
description: 规则文件的简短描述，说明内容和用途
alwaysApply: false  # 大多数情况下使用 false
---
```

**重要字段说明**：

- **`description`**（必需）：
  - 描述规则文件的内容和用途
  - 帮助 AI 理解何时应该参考这个规则文件
  - 长度建议：50-150 字符
  - 示例：`认证系统开发规则和参考`

- **`alwaysApply`**（必需）：
  - `true`：规则文件总是被应用（适用于通用基础规则）
  - `false`：规则文件只在相关上下文时被应用（大多数情况下使用）
  - 只有通用基础规则和项目特定规则使用 `true`

#### 4. 编写规则内容

规则内容应该包括：

- **核心原则**：规则文件遵循的核心原则
- **参考文件**：相关的文档和代码文件
- **开发规范**：具体的开发规范和最佳实践
- **示例代码**：示例代码和反例对比
- **常见任务**：常见开发任务的步骤
- **注意事项**：重要的注意事项和陷阱

**推荐结构**：

```markdown
---
description: 规则文件描述
alwaysApply: false
---

# 规则文件标题

## 核心原则

规则文件遵循的核心原则...

## 开发相关功能时的参考文件

### 1. 主要文档

**文件位置**：`docs/xxx.md`
**用途**：...

### 2. 相关代码

**文件位置**：`app/xxx/xxx.rb`
**用途**：...

## 开发规范

### 代码规范示例

```ruby
# 示例代码
```

## 常见任务

### 任务 1：...

步骤说明...

## 注意事项

1. 注意事项 1
2. 注意事项 2

## 相关文件索引

- 文档：`docs/xxx.md`
- 代码：`app/xxx/xxx.rb`
```

### 更新现有规则

直接编辑 `.cursor/rules/` 目录下的 `.mdc` 文件即可。修改后，AI 会自动识别新的规则内容。

### 规则文件示例

查看现有规则文件作为参考：

- **base.mdc**：通用基础规则（`alwaysApply: true`）
- **workspace.mdc**：项目特定规则（`alwaysApply: true`）
- **authentication.mdc**：认证系统开发规则（`alwaysApply: false`）
- **daisy-ui.mdc**：DaisyUI 前端开发规则（`alwaysApply: false`）

### 参考文档

详细指南请参考：`.cursor/rules/cursor-rules.mdc`

## 保存开发经验

### 什么是经验？

经验（Experiences）是开发过程中遇到的疑难问题和解决方案的记录，存放在 `docs/experiences/` 目录下，便于后续遇到类似问题时快速参考。

### 经验文件位置

所有经验文件存放在 `docs/experiences/` 目录下，文件扩展名为 `.md`。

### 创建新经验

#### 1. 确定经验主题

在创建经验前，先思考：

- 遇到了什么问题？
- 问题的根本原因是什么？
- 解决方案是什么？
- 有哪些关键经验可以总结？

#### 2. 创建经验文件

在 `docs/experiences/` 目录下创建新的 `.md` 文件：

```bash
# 使用命令行创建
touch docs/experiences/my-experience.md

# 或使用 Cursor 编辑器直接创建
```

**命名规范**：

- ✅ 使用小写字母和连字符：`my-experience.md`
- ✅ 使用描述性名称：`highlight.js.md`、`warden-custom-failure.md`
- ✅ 可以使用技术名称：`importmap-ssl-certificate-error.md`
- ❌ 避免使用下划线：`my_experience.md`
- ❌ 避免使用空格：`my experience.md`

#### 3. 编写经验内容

经验文件使用 Markdown 格式，**必须**在文件开头使用 YAML frontmatter 格式定义元数据。

**推荐结构**：

```markdown
---
date: YYYY-MM-DD
problem_type: 前端集成 / 后端逻辑 / 配置问题 / 性能优化
status: 已解决 / 进行中 / 未解决
---

# [问题标题]

## 问题描述

详细描述遇到的问题和现象。

## 问题原因分析

分析问题的根本原因。

## 解决方案

### 步骤 1：...

详细说明...

### 步骤 2：...

详细说明...

## 关键经验总结

总结关键经验和注意事项。

## 相关文件

- `path/to/file.rb`
- `path/to/file.js`

## 参考资料

- [链接标题](URL)
```

**元数据字段说明**：

- `date`：经验记录的日期，格式为 `YYYY-MM-DD`
- `problem_type`：问题类型，可以是：前端集成、后端逻辑、配置问题、性能优化等
- `status`：状态，可以是：已解决、进行中、未解决

#### 4. 更新经验索引

在 `docs/experiences/README.md` 中添加经验索引：

```markdown
## 📋 经验列表

### 前端集成

- [Highlight.js 集成问题](./highlight.js.md) (2025-11-25)
  - Importmap 路径配置
  - ES Module vs CommonJS 兼容性
  - Stimulus Controller 初始化

### 后端逻辑 / 认证系统

- [Warden custom_failure! 使用经验](./warden-custom-failure.md) (2025-11-29)
  - API 控制器返回 401 时避免 Warden 拦截
  - custom_failure! 的使用场景和注意事项
```

### 查看经验

经验可以通过以下方式查看：

1. **本地文件**：直接查看 `docs/experiences/` 目录下的文件
2. **Web 界面**：访问 `/experiences` 路径查看所有经验列表
3. **单个经验**：访问 `/experiences/:id` 路径查看单个经验详情

### 经验文件示例

查看现有经验文件作为参考：

- **warden-custom-failure.md**：Warden custom_failure! 使用经验
- **importmap-ssl-certificate-error.md**：Importmap SSL 证书验证错误
- **highlight.js.md**：Highlight.js 集成问题

### 参考文档

详细指南请参考：`docs/experiences/README.md`

## 记录技术栈规则

### 什么是技术栈规则？

技术栈规则是记录项目使用的技术栈的开发规范和最佳实践，存放在 `.cursor/rules/` 目录下，可以通过 Web 界面查看。

### 技术栈规则位置

技术栈规则文件存放在 `.cursor/rules/` 目录下，文件扩展名为 `.mdc`。

### 创建技术栈规则

#### 1. 确定技术栈主题

在创建技术栈规则前，先思考：

- 项目使用了哪些技术栈？
- 每个技术栈有哪些开发规范？
- 有哪些最佳实践需要记录？

#### 2. 创建规则文件

技术栈规则就是普通的规则文件，按照[创建和管理规则](#创建和管理规则)的步骤创建即可。

**命名规范**：

- ✅ 使用技术栈名称：`daisy-ui.mdc`、`action-policy.mdc`
- ✅ 使用小写字母和连字符
- ❌ 避免使用下划线或空格

#### 3. 注册技术栈

在 `app/controllers/tech_stack_controller.rb` 中注册技术栈：

```ruby
TECH_STACK_RULES = {
  "daisy-ui" => {
    name: "DaisyUI",
    icon: "daisyui-logo.svg",  # 可选，SVG 图标文件名
    description: "Tailwind CSS 组件库"
  },
  "action-policy" => {
    name: "Action Policy",
    icon: nil,  # 如果没有图标，使用 nil
    description: "授权框架"
  }
}.freeze
```

#### 4. 编写规则内容

技术栈规则的内容应该包括：

- **核心原则**：技术栈使用的核心原则
- **参考文档**：官方文档和参考资料
- **开发规范**：具体的开发规范和最佳实践
- **代码示例**：示例代码和反例对比
- **常见任务**：常见开发任务的步骤
- **注意事项**：重要的注意事项和陷阱

**推荐结构**：

```markdown
---
description: [技术栈名称] 开发规则和最佳实践
alwaysApply: false
---

# [技术栈名称] 开发规则

## 核心原则

1. 原则 1
2. 原则 2

## 官方文档

- [官方文档](URL)
- [API 参考](URL)

## 开发规范

### 代码规范示例

```ruby
# 示例代码
```

## 常见任务

### 任务 1：...

步骤说明...

## 注意事项

1. 注意事项 1
2. 注意事项 2
```

### 查看技术栈规则

技术栈规则可以通过以下方式查看：

1. **本地文件**：直接查看 `.cursor/rules/` 目录下的文件
2. **Web 界面**：访问 `/tech_stack/:id` 路径查看技术栈规则详情

例如：

- `/tech_stack/daisy-ui`：查看 DaisyUI 规则
- `/tech_stack/action-policy`：查看 Action Policy 规则

### 技术栈规则示例

查看现有技术栈规则作为参考：

- **daisy-ui.mdc**：DaisyUI 前端开发规则
- **action-policy.mdc**：Action Policy 授权框架规则
- **authentication.mdc**：认证系统开发规则

## 最佳实践

### 指令 vs 规则

**指令（Commands）**：
- 定义 AI 的工作方式和行为模式
- 适用于特定场景下的工作流程
- 文件扩展名：`.md`
- 不需要头部元数据

**规则（Rules）**：
- 提供开发规范和最佳实践
- 适用于开发相关功能时的参考
- 文件扩展名：`.mdc`
- 需要头部元数据（`description` 和 `alwaysApply`）

### 何时创建指令？

创建指令的场景：

- ✅ 需要定义 AI 的工作流程
- ✅ 需要规范 AI 的行为模式
- ✅ 需要定义特定场景下的执行方式

示例：

- 继续完成项目工作
- 智能继续工作
- 自主工作模式
- 日报管理

### 何时创建规则？

创建规则的场景：

- ✅ 需要提供开发规范
- ✅ 需要记录最佳实践
- ✅ 需要记录技术栈使用规范

示例：

- 认证系统开发规范
- DaisyUI 前端开发规范
- Action Policy 授权框架规范
- Rails 缓存开发规范

### 何时保存经验？

保存经验的场景：

- ✅ 遇到疑难问题并已解决
- ✅ 解决方案有参考价值
- ✅ 需要记录关键经验

示例：

- 第三方库集成问题
- 配置问题
- 性能优化经验
- 安全相关经验

### 何时记录技术栈？

记录技术栈的场景：

- ✅ 项目使用了新的技术栈
- ✅ 技术栈有特定的使用规范
- ✅ 需要记录最佳实践

示例：

- 前端框架（DaisyUI、Tailwind CSS）
- 后端框架（Rails、Warden）
- 授权框架（Action Policy）
- 缓存系统（Solid Cache）

## 常见问题

### Q1: 指令和规则有什么区别？

**A**: 指令定义 AI 的工作方式，规则提供开发规范。指令是 `.md` 文件，不需要元数据；规则是 `.mdc` 文件，需要头部元数据。

### Q2: 如何让 AI 自动识别我的规则？

**A**: 确保规则文件的 `description` 字段清晰明确，包含相关的技术关键词。AI 会根据 `description` 自动识别何时应该参考这个规则。

### Q3: 经验文件可以放在其他目录吗？

**A**: 不建议。经验文件应该统一放在 `docs/experiences/` 目录下，这样可以：

- 统一管理
- 通过 Web 界面查看
- 便于索引和搜索

### Q4: 技术栈规则必须注册吗？

**A**: 不是必须的。如果只是作为开发参考，可以不注册。但如果需要通过 Web 界面查看，需要在 `TechStackController` 中注册。

### Q5: 如何让 AI 使用我的指令？

**A**: 在 Cursor 中使用斜线命令执行指令，例如：

```bash
/continue-project-work
/smart-go
/autonomous-work
```

或者直接描述指令内容，AI 会自动识别。

### Q6: 规则文件的 `alwaysApply` 应该设置为什么？

**A**: 大多数情况下使用 `false`。只有以下情况使用 `true`：

- 通用基础规则（如 `base.mdc`）
- 项目特定规则（如 `workspace.mdc`）

其他规则文件应该使用 `false`，避免增加 AI 的上下文负担。

### Q7: 如何更新现有的指令或规则？

**A**: 直接编辑对应的文件即可。修改后，AI 会自动识别新的内容。不需要重启或重新加载。

### Q8: 经验文件需要什么格式？

**A**: 经验文件使用 Markdown 格式，**必须**在文件开头使用 YAML frontmatter 格式定义元数据（日期、问题类型、状态），建议包含：

- **元数据**（YAML frontmatter）：
  - `date`：经验记录的日期
  - `problem_type`：问题类型
  - `status`：状态（已解决/进行中/未解决）
- **内容结构**：
  - 问题描述
  - 问题原因分析
  - 解决方案
  - 关键经验总结
  - 相关文件列表
  - 参考资料

详细模板请参考 `docs/experiences/README.md`。

## 相关资源

### 文档索引

- [项目主页](../README.md)
- [开发者指南](DEVELOPER_GUIDE.md)
- [使用指南](USAGE_GUIDE.md)
- [功能清单](FEATURES.md)

### 规则文件

- [指令文件创建指南](../.cursor/rules/cursor-commands.mdc)
- [规则文件创建指南](../.cursor/rules/cursor-rules.mdc)
- [通用基础规则](../.cursor/rules/base.mdc)
- [项目特定规则](../.cursor/rules/workspace.mdc)

### 经验库

- [经验索引](experiences/README.md)
- [经验列表](experiences/)

---

**最后更新**：2025-12-04  
**维护者**：BuildX.work 团队

