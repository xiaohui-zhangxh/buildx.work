# 合并贡献代码

## 概述

将来自贡献分支的代码合并到主分支（main），适用于 buildx.work 基础平台项目，用于合并来自贡献者的代码。

**重要原则**：按照 GitHub PR 原则，谁提交的代码，谁有责任合并主分支代码进行代码测试。如果发现贡献代码有问题，应该让贡献者自己修复，而不是自己优先去修复。

### 使用方式

**Cursor 斜线命令**：`/merge-contribution`  
**直接描述**：`合并贡献代码`、`合并贡献分支`、`合并 PR`、`合并贡献`

**指定分支**：
- `/merge-contribution [分支名]`：合并指定的贡献分支
- `/merge-contribution contribute/add-ruby-llm-config-and-improvements`：合并指定的贡献分支

## 🎯 核心原则

1. **自动保存工作**：如果分支不干净，自动创建分支保存当前工作，不询问用户
2. **深度代码审查**：必须仔细阅读贡献代码的内容，不能只关注文件名，必须分析代码逻辑、依赖关系、潜在影响
3. **风险分析优先**：先分析贡献内容和潜在影响，给出详细风险提示
4. **用户确认**：必须等待用户明确确认后才执行合并
5. **信息透明**：显示将要合并的贡献内容、风险分析和影响评估
6. **让贡献者修复问题**：如果发现贡献代码有问题（如缺失方法、依赖问题等），应该让贡献者自己修复，而不是自己优先去修复
7. **使用 merge 策略**：使用 `git merge` 而不是 `git rebase`，保留贡献者的提交历史
8. **冲突处理**：检测并协助处理合并过程中的冲突
9. **可回退**：提供回退选项，确保操作安全
10. **验证结果**：合并后验证结果，运行测试确保功能正常

## 🔍 工作流程

### 步骤 1：检查项目类型和 Git 状态

**目标**：确认当前项目是 buildx.work 基础平台项目，并检查 Git 状态。

**方法**：

1. **检查项目类型**：
   - 检查是否存在 `docs/project-*/` 目录
   - 检查 Git Remote 配置
   - 如果是 fork 项目，提示用户此指令适用于基础平台项目

2. **检查 Git 状态并自动处理**：
   ```bash
   git status --short
   ```
   - **如果当前分支不干净**（有未提交的变更）：
     - **自动创建分支保存当前工作**，不询问用户：
       ```bash
       # 记录当前分支名称
       CURRENT_BRANCH=$(git branch --show-current)
       
       # 创建临时分支保存当前工作（包含操作类型和时间戳，便于识别）
       git checkout -b wip/merge-contribution-$(date +%Y%m%d-%H%M%S)
       git add .
       git commit -m "WIP: 保存当前工作进度（合并贡献前自动暂存）"
       
       # 切换回原分支（此时原分支应该是干净的）
       git checkout $CURRENT_BRANCH
       ```
     - **记录暂存分支名称**，用于步骤 8 切换回去
     - **继续执行下一步**（不再停止）
   - **如果当前分支干净**：
     - 继续执行下一步

3. **检查当前分支**：
   ```bash
   git branch --show-current
   ```
   - 建议在 main 分支执行
   - 如果不在 main 分支，提示用户切换

**输出**：
- 项目类型确认
- Git 状态摘要
- 当前分支信息
- 如果有未提交的变更：
  - 列出变更文件
  - 自动创建暂存分支
  - 显示暂存分支名称
  - 提示已自动处理，继续执行

**注意**：
- 这是**必须步骤**，如果当前分支不干净，**自动创建分支保存当前工作**，然后继续执行
- 暂存分支命名格式：`wip/merge-contribution-{timestamp}`，包含操作类型（merge-contribution）和时间戳，便于识别和恢复
- 暂存分支会在步骤 8 中用于切换回之前的工作

### 步骤 2：识别贡献分支

**目标**：识别要合并的贡献分支。

**方法**：

1. **如果用户指定了分支名**：
   - 使用用户指定的分支名
   - 验证分支是否存在：
     ```bash
     git branch -a | grep <分支名>
     ```

2. **如果用户没有指定分支名**：
   - 查找所有贡献分支：
     ```bash
     git branch -a | grep -E "(contribute|contribution)" | grep -v HEAD
     ```
   - 列出所有贡献分支，让用户选择
   - 或者自动选择最新的贡献分支（如果只有一个）

3. **验证贡献分支存在**：
   ```bash
   git show-branch <贡献分支名> 2>/dev/null || echo "分支不存在"
   ```

**输出**：
- 贡献分支列表（如果用户没有指定）
- 选定的贡献分支名称
- 贡献分支的提交数量

### 步骤 3：获取贡献分支最新代码

**目标**：确保本地有贡献分支的最新代码。

**方法**：

```bash
# 获取贡献分支的最新代码
git fetch origin <贡献分支名>
```

**输出**：
- 获取结果（成功/失败）
- 如果失败，提示用户检查网络连接或权限

### 步骤 4：深度代码审查和依赖分析（重要）

**目标**：仔细阅读贡献代码的内容，分析代码逻辑、依赖关系、潜在影响，不能只关注文件名。

**重要规则**：

1. **必须仔细阅读代码内容**：不能只关注文件名，必须深入分析代码内容
2. **分析代码逻辑**：理解代码的功能、实现方式、设计决策
3. **分析依赖关系**：检查代码引用了哪些类、方法、模块，这些依赖是否存在
4. **识别潜在问题**：识别缺失的方法、类、模块，识别可能的问题
5. **发现问题时让贡献者修复**：如果发现贡献代码有问题，应该让贡献者自己修复，而不是自己优先去修复

**方法**：

1. **查看贡献摘要**：
   ```bash
   # 查看贡献分支有哪些提交（主分支还没有的）
   git log main..<贡献分支名> --oneline
   ```

2. **查看贡献统计**：
   ```bash
   # 查看贡献的统计信息
   git diff --stat main..<贡献分支名>
   ```

3. **查看贡献的文件列表**：
   ```bash
   # 查看贡献的文件列表
   git diff --name-status main..<贡献分支名>
   ```

4. **仔细阅读每个文件的变更内容**（重要）：
   ```bash
   # 查看每个文件的具体变更
   git diff main..<贡献分支名> -- <文件路径>
   ```

5. **分析代码依赖关系**（重要）：
   - **检查方法调用**：
     - 代码中调用了哪些方法？
     - 这些方法是否存在？
     - 这些方法在哪个类或模块中？
   
   - **检查类引用**：
     - 代码中引用了哪些类？
     - 这些类是否存在？
     - 这些类是否需要导入？
   
   - **检查模块引用**：
     - 代码中引用了哪些模块？
     - 这些模块是否存在？
     - 这些模块是否需要 include 或 require？
   
   - **检查配置文件**：
     - 代码是否依赖配置文件？
     - 配置文件是否存在？
     - 配置文件的内容是否正确？

6. **识别缺失的依赖**（重要）：
   - 如果代码调用了不存在的方法，必须识别
   - 如果代码引用了不存在的类，必须识别
   - 如果代码引用了不存在的模块，必须识别
   - 如果代码依赖不存在的配置文件，必须识别

7. **分析代码逻辑**：
   - 代码的功能是什么？
   - 代码的实现方式是否合理？
   - 代码是否有潜在的问题？
   - 代码是否符合项目规范？

8. **分析影响范围**：
   - 代码会影响哪些其他文件？
   - 代码是否会影响现有功能？
   - 代码是否需要更新测试？
   - 代码是否需要更新文档？

**输出**：
- 贡献提交列表（最近 10 条）
- 贡献统计信息（文件数量、行数）
- 贡献文件列表摘要
- **详细的代码审查报告**：
  - 每个文件的具体变更内容
  - 代码逻辑分析
  - 依赖关系分析
  - 缺失依赖列表（如果有）
  - 潜在问题列表（如果有）
  - 影响范围分析

**发现问题时的处理**：

如果发现贡献代码有问题（如缺失方法、依赖问题等），应该：

1. **生成问题报告**：
   - 列出所有发现的问题
   - 说明每个问题的原因
   - 说明如何修复问题

2. **让贡献者修复**：
   - 不要自己优先去修复问题
   - 应该让贡献者自己修复问题
   - 可以给出修复建议，但不要直接修复

3. **等待贡献者修复后再合并**：
   - 如果问题严重，应该等待贡献者修复后再合并
   - 如果问题不严重，可以在合并后让贡献者修复

**示例**：

```
发现的问题：
1. config/initializers/100_system_config.rb 中调用了 SystemConfig.ensure_config 方法
2. 但 SystemConfig 模型中不存在 ensure_config 方法
3. 这会导致代码无法运行

处理建议：
- 应该让贡献者自己添加 ensure_config 方法
- 或者让贡献者修改代码，使用现有的 SystemConfig.set 方法
- 不应该自己添加 ensure_config 方法
```

### 步骤 5：深度分析贡献内容和风险评估

**目标**：基于步骤 4 的代码审查，深度分析贡献分支的内容，识别可能影响主分支的文件，评估冲突风险，给出详细的风险提示。

**方法**：

1. **分析贡献类型**：
   - 功能更新
   - 修复更新
   - 文档更新
   - 配置更新
   - 测试更新

2. **识别可能冲突的文件**（重要）：
   ```bash
   # 检查哪些文件在贡献分支和主分支中都被修改了
   git diff --name-only main..<贡献分支名> | while read file; do
     if git diff --quiet main -- "$file" 2>/dev/null; then
       # 文件在主分支中没有修改，风险低
       echo "LOW:$file"
     else
       # 文件在主分支中有修改，风险高
       echo "HIGH:$file"
     fi
   done
   ```

3. **分析关键文件变更**：
   - **基础设施文件**（如 `app/models/user.rb`、`app/controllers/application_controller.rb`）：
     - 检查贡献的变更是否会影响现有功能
     - 识别可能被覆盖的代码
   
   - **配置文件**（如 `config/routes.rb`、`config/application.rb`）：
     - 检查是否有路由冲突
     - 检查是否有配置冲突
   
   - **数据库迁移**（如 `db/migrate/*.rb`）：
     - 检查是否有新的迁移文件
     - 评估是否需要运行迁移
   
   - **测试文件**（如 `test/**/*_test.rb`）：
     - 检查测试文件的变更
     - 评估是否会影响现有测试

4. **评估影响范围**：
   - **高风险文件**：主分支和贡献分支都修改的文件
   - **中风险文件**：贡献分支修改了主分支可能依赖的文件
   - **低风险文件**：新增文件或主分支未修改的文件

5. **生成风险报告**：
   - 列出所有可能冲突的文件
   - 分析每个文件的风险等级
   - 给出处理建议

**输出**：
- **风险分析报告**：
  - 高风险文件列表（可能冲突）
  - 中风险文件列表（需要关注）
  - 低风险文件列表（安全）
  - 每个文件的风险说明和处理建议
- **影响评估**：
  - 可能影响的功能
  - 需要手动处理的文件
  - 建议的处理策略
- **发现的问题**（如果有）：
  - 问题列表
  - 问题说明
  - 处理建议（让贡献者修复）

### 步骤 6：显示风险报告并等待确认

**目标**：基于步骤 4 和 5 的分析，生成详细的风险报告，等待用户确认后再执行合并。

**重要规则**：

1. **必须等待确认**：执行合并前必须等待用户明确确认
2. **显示详细风险报告**：显示贡献摘要、代码审查结果、风险分析和影响评估
3. **显示发现的问题**：如果发现问题，必须显示问题列表和处理建议
4. **强调让贡献者修复**：如果发现问题，必须强调应该让贡献者自己修复

**执行流程**：

1. **生成并显示风险报告**：
   ```
   ⚠️ 合并贡献代码 - 代码审查和风险分析报告
   
   📊 贡献摘要：
   - 贡献分支：contribute/add-ruby-llm-config-and-improvements
   - 贡献提交数：10 个提交
   - 贡献文件数：15 个文件
   - 新增行数：+500
   - 删除行数：-50
   
   📝 主要贡献类型：
   - 功能更新：6 个提交
   - 修复更新：2 个提交
   - 文档更新：2 个提交
   
   🔍 代码审查结果：
   
   **发现的问题**：
   1. config/initializers/100_system_config.rb 中调用了 SystemConfig.ensure_config 方法
      - 问题：SystemConfig 模型中不存在 ensure_config 方法
      - 影响：代码无法运行，会导致 NoMethodError
      - 处理建议：应该让贡献者自己添加 ensure_config 方法，不应该自己修复
   
   **依赖关系分析**：
   - 新增文件：config/initializers/ruby_llm.rb（依赖 RubyLLM gem，已在 Gemfile 中添加）
   - 修改文件：config/initializers/100_system_config.rb（依赖 SystemConfig.ensure_config 方法，但该方法不存在）
   
   ⚠️ 风险评估：
   
   🔴 高风险文件（可能冲突，需要手动处理）：
   1. config/initializers/100_system_config.rb
      - 风险：贡献分支添加了新配置逻辑，主分支也修改了相同位置
      - 影响：可能覆盖主分支的配置
      - 建议：合并后检查并合并配置
   
   🟡 中风险文件（需要关注）：
   1. app/controllers/application_controller.rb
      - 风险：贡献分支修改了基础控制器
      - 影响：可能影响现有控制器功能
      - 建议：合并后检查控制器功能是否正常
   
   🟢 低风险文件（安全）：
   - .cursor/rules/ai-development.mdc（新增）
   - docs/AI_USAGE_GUIDE.md（更新）
   - lib/ruby_llm.rb（新增）
   
   💡 处理建议：
   1. 建议先备份当前代码（已完成，已保存到 wip/merge-contribution-{timestamp} 分支）
   2. **如果发现问题，应该让贡献者自己修复，不应该自己修复**
   3. 执行合并后，优先处理高风险文件的冲突
   4. 运行测试确保功能正常：bin/rails test
   5. 如有问题，可以使用 git merge --abort 回退
   
   ⚠️ 重要提示：
   - 如果合并过程中出现冲突，需要手动解决
   - 解决冲突后，使用 git add <文件> 和 git commit 继续
   - 如果遇到无法解决的问题，可以使用 git merge --abort 取消合并
   - **如果发现贡献代码有问题，应该让贡献者自己修复，不应该自己修复**
   
   是否确认执行合并？(yes/no)
   ```

2. **处理用户响应**：
   - **yes**：执行合并（进入步骤 7）
   - **no**：取消操作，提示用户可以稍后再试

**输出**：
- 详细的代码审查报告
- 贡献摘要和统计
- 发现的问题列表（如果有）
- 风险评估和处理建议
- 等待用户确认

### 步骤 7：执行合并

**目标**：用户确认后执行合并操作。

**执行流程**：

1. **执行合并**（用户确认后）：
   ```bash
   # 使用 merge 策略合并贡献分支（保留贡献者的提交历史）
   git merge <贡献分支名> --no-ff -m "Merge: <贡献分支名>

   <贡献描述>

   - 贡献者：<贡献者信息>
   - 提交数：<提交数量>
   - 文件数：<文件数量>
   "
   ```

2. **检查合并结果**：
   ```bash
   # 检查合并状态
   git status
   ```

**输出**：
- 合并执行结果
- 如果有冲突，显示冲突信息（进入步骤 8）
- 如果成功，进入步骤 9

### 步骤 8：处理冲突（如有）

**目标**：如果合并过程中出现冲突，协助用户处理。

**方法**：

1. **检测冲突**：
   ```bash
   git status
   ```
   - 查看冲突文件列表
   - 查看冲突状态

2. **显示冲突信息**：
   ```
   检测到冲突，需要手动解决：
   
   冲突文件：
   - config/initializers/100_system_config.rb
   - app/assets/tailwind/application.css
   
   冲突说明：
   - config/initializers/100_system_config.rb：贡献分支添加了新配置，主分支也修改了相同位置
   - app/assets/tailwind/application.css：贡献分支修改了样式，主分支也修改了样式
   
   请手动解决冲突后，使用以下命令继续：
   git add <解决冲突的文件>
   git commit
   
   或者取消合并：
   git merge --abort
   ```

3. **等待用户解决冲突**：
   - 用户手动解决冲突
   - 用户标记冲突已解决（`git add`）
   - 用户继续合并（`git commit`）

**输出**：
- 冲突文件列表
- 冲突说明和建议
- 继续或取消的选项

### 步骤 9：验证合并结果

**目标**：合并完成后，验证合并结果，运行测试确保功能正常。

**方法**：

1. **检查合并状态**：
   ```bash
   git status
   git log --oneline -10
   ```

2. **运行测试**：
   ```bash
   # 运行所有测试
   bin/rails test
   ```

3. **检查代码质量**：
   ```bash
   # 运行 RuboCop 检查
   bin/rubocop
   ```

4. **检查测试覆盖率**（如果配置了）：
   ```bash
   # 查看测试覆盖率
   open coverage/index.html
   ```

**输出**：
- 合并状态确认
- 测试结果
- 代码质量检查结果
- 如果有问题，提示用户处理

**如果测试失败**：

如果测试失败，应该：

1. **分析失败原因**：
   - 检查错误信息
   - 识别问题所在

2. **让贡献者修复**：
   - 不应该自己优先去修复
   - 应该让贡献者自己修复问题
   - 可以给出修复建议

3. **回退合并**（如果问题严重）：
   ```bash
   git merge --abort
   ```

### 步骤 10：清理并切换回之前的工作

**目标**：合并完成后，清理并切换回之前的工作分支（如果之前自动创建了暂存分支）。

**方法**：

1. **记录之前的工作分支**：
   - 在步骤 1 中，如果分支不干净，自动创建了暂存分支（如 `wip/merge-contribution-20251203-213335`），记录该分支名称
   - 如果分支干净，记录当前分支名称（如 `main`）

2. **切换回之前的工作分支**（如果需要）：
   ```bash
   # 如果之前的工作在 wip 分支（步骤 1 自动创建的）
   git checkout wip/merge-contribution-{timestamp}
   
   # 如果之前的工作在 main 分支或其他分支
   git checkout {原分支名称}
   ```

3. **合并主分支的更新**（如果需要）：
   - 如果之前的工作在 wip 分支，可以合并 main 分支的更新：
     ```bash
     git merge main
     ```
   - 或者继续在 main 分支工作（如果之前的工作已经不重要）

**输出**：
- 切换回之前的工作分支
- 提示可以继续开发

### 步骤 11：显示合并总结

**目标**：显示合并总结，提供后续操作建议。

**方法**：

1. **显示合并总结**：
   ```
   ✅ 合并完成！
   
   合并结果：
   - 成功合并贡献分支：contribute/add-ruby-llm-config-and-improvements
   - 合并提交数：10 个提交
   - 更新 15 个文件
   - 新增 500 行，删除 50 行
   
   当前状态：
   - 分支：main
   - 状态：干净（无冲突）
   - 测试结果：所有测试通过
   - 代码质量：通过 RuboCop 检查
   
   ⚠️ 重要提醒：
   - 如果之前自动创建了暂存分支（wip/merge-contribution-{timestamp}），记得切换回去或合并更新
   - 建议推送到远程仓库：git push origin main
   - 如果贡献分支来自 Pull Request，记得关闭 PR
   - 如果发现贡献代码有问题，应该让贡献者自己修复，不应该自己修复
   
   下一步：
   - 推送更新：git push origin main
   - 关闭 Pull Request（如果适用）
   - 更新文档（如果需要）
   ```
```

**输出**：
- 合并结果摘要
- 当前 Git 状态
- 测试和代码质量检查结果
- 下一步建议

## ⚠️ 重要规则

1. **自动保存工作**：如果分支不干净，自动创建分支保存当前工作，不询问用户
2. **深度代码审查**：必须仔细阅读贡献代码的内容，不能只关注文件名，必须分析代码逻辑、依赖关系、潜在影响
3. **让贡献者修复问题**：如果发现贡献代码有问题（如缺失方法、依赖问题等），应该让贡献者自己修复，而不是自己优先去修复
4. **风险分析优先**：必须先进行深度风险分析，识别可能冲突的文件
5. **必须等待确认**：执行合并前必须等待用户明确确认
6. **显示详细风险报告**：显示贡献摘要、代码审查结果、风险分析和影响评估
7. **使用 merge 策略**：使用 `git merge` 而不是 `git rebase`，保留贡献者的提交历史
8. **冲突处理**：检测冲突并提供处理建议
9. **可回退**：提供回退选项（`git merge --abort`）
10. **信息透明**：显示贡献摘要和风险分析，让用户充分了解变更和风险
11. **验证结果**：合并后验证结果，运行测试确保功能正常
12. **清理工作**：合并完成后，切换回之前的工作分支（如果自动创建了暂存分支）

## 🔧 技术细节

### Git 命令参考

```bash
# 检查 Git 状态
git status
git status --short

# 查找贡献分支
git branch -a | grep -E "(contribute|contribution)"

# 获取贡献分支最新代码
git fetch origin <贡献分支名>

# 查看贡献内容
git log main..<贡献分支名> --oneline
git diff --stat main..<贡献分支名>
git diff --name-status main..<贡献分支名>
git diff main..<贡献分支名> -- <文件路径>

# 自动保存当前工作到分支（如果分支不干净）
CURRENT_BRANCH=$(git branch --show-current)
git checkout -b wip/merge-contribution-$(date +%Y%m%d-%H%M%S)
git add .
git commit -m "WIP: 保存当前工作进度（合并贡献前自动暂存）"
git checkout $CURRENT_BRANCH  # 切换回原分支（现在干净了）

# 执行合并（使用 merge 策略，保留贡献者提交历史）
git merge <贡献分支名> --no-ff -m "Merge: <贡献分支名>

<贡献描述>

- 贡献者：<贡献者信息>
- 提交数：<提交数量>
- 文件数：<文件数量>
"

# 处理冲突
git status                    # 查看冲突文件
git add <解决冲突的文件>      # 标记冲突已解决
git commit                    # 继续合并

# 取消合并
git merge --abort

# 切换回之前的工作分支（如果自动创建了暂存分支）
git checkout wip/merge-contribution-{timestamp}

# 查看提交历史
git log --oneline -10
git log --oneline --graph
```

### 冲突处理策略

1. **基础设施文件冲突**（如 `app/models/user.rb`）：
   - **策略**：优先保留主分支的代码，合并贡献的改进
   - **原因**：基础设施代码需要保持稳定
   - **例外**：如果贡献的改进是通用改进，应该合并

2. **配置文件冲突**（如 `config/routes.rb`）：
   - **策略**：合并双方的更改
   - **原因**：配置需要同时保留现有配置和贡献的配置

3. **新增文件冲突**（如 `lib/ruby_llm.rb`）：
   - **策略**：保留贡献的新文件
   - **原因**：新增文件通常不会冲突

4. **文档冲突**（如 `README.md`）：
   - **策略**：合并双方的更改
   - **原因**：文档可以同时保留多个内容

### 回退方法

如果合并失败或需要回退：

```bash
# 取消合并，回到合并前的状态
git merge --abort

# 或者使用 reflog 查看历史
git reflog

# 回退到指定提交
git reset --hard <commit-hash>
```

## 💡 使用示例

### 示例 1：发现贡献代码有问题

```
用户：/merge-contribution contribute/add-ruby-llm-config-and-improvements

AI 执行：
1. 检查项目类型和 Git 状态：✅
2. 识别贡献分支：✅
3. 获取贡献分支最新代码：✅
4. 深度代码审查和依赖分析：
   → 仔细阅读 config/initializers/100_system_config.rb 的变更
   → 发现调用了 SystemConfig.ensure_config 方法
   → 检查 SystemConfig 模型，发现不存在 ensure_config 方法
   → 识别问题：缺失 ensure_config 方法
   
5. 显示风险报告并等待确认：
   → ⚠️ 合并贡献代码 - 代码审查和风险分析报告
   → 显示发现的问题：SystemConfig.ensure_config 方法不存在
   → 处理建议：应该让贡献者自己添加 ensure_config 方法，不应该自己修复
   → 是否确认执行合并？(yes/no)

用户：yes（但应该让贡献者修复）

AI 执行：
6. 执行合并：✅
7. 处理冲突（如有）：无冲突
8. 验证合并结果：
   → 运行测试：bin/rails test
   → 测试失败：NoMethodError: undefined method `ensure_config'
   → 分析失败原因：缺失 ensure_config 方法
   → 建议：应该让贡献者自己修复，不应该自己修复
   → 可以回退合并：git merge --abort
```

## 📚 相关资源

- [代码贡献指令](80-contribute-code.md) - 如何贡献代码到基础平台
- [同步基础平台更新指令](81-sync-upstream.md) - 如何同步基础平台更新到业务项目
- [Git 提交助手](90-commit-assistant.md) - 协助提交代码

---

**创建时间**：2025-12-04  
**最后更新**：2025-12-04  
**变更说明**：
- 强调深度代码审查，不能只关注文件名，必须分析代码内容、依赖关系
- 强调让贡献者修复问题，而不是自己优先去修复
- 添加代码审查步骤和依赖分析步骤
- 添加发现问题时的处理流程

**指令类型**：通用指令  
**适用项目**：buildx.work 基础平台项目  
**相关文档**：`docs/FEATURE_CONTRIBUTION.md`

